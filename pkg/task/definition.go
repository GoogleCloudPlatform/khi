// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package task

import (
	"context"

	"github.com/GoogleCloudPlatform/khi/pkg/task/taskid"
)

const (
	KHISystemPrefix      = "khi.google.com/"
	LabelKeyThreadUnsafe = KHISystemPrefix + "thread-unsafe"
	// KHI allows tasks with different ID suffixes to be specified as dependencies
	// using only the ID without the suffix. For example, both `a.b.c/qux#foo` and `a.b.c/qux#bar`
	// can be specified as a dependency using `a.b.c/qux`.
	//
	// Normally, the task ID is uniquely determined by the task filter or other
	// ways. However, if multiple tasks exist, the value specified with this label
	// with the highest priority is used.
	LabelKeyTaskSelectionPriority = KHISystemPrefix + "task-selection-priority"
)

// Definition represents a task definition that behaves as a factory of the task runner itself and contains metadata of dependency and labels.
// The implementation of ID and Labels must be deterministic when the application started.
// The implementation of Sinks and Source must be pure function not depending anything outside of the argument.
type Definition interface {
	// ID returns a string unique for each Definition
	// The implementation of this function must return a constant value.
	// Each definition ID must be unique but ID can have suffix beginning with #. Dependencies field will ignore the suffix.
	// This is useful when task A depends on the value B but value B can be generated from task B-1 or B-2 and the task set would be differently generated by some condition.
	// In the case, task Ids would be `B#1` and `B#2` and these could be depnd by specifying `B` in the Dependencies.
	ID() taskid.TaskImplementationId
	// Labels returns KHITaskLabelSet assigned to this task unit.
	// The implementation of this function must return a constant value.
	Labels() *LabelSet

	// Dependencies returns the set of Definition ids without the suffix beginning with #. Task runner will wait these dependent tasks to be done before running this task.
	Dependencies() []taskid.TaskReferenceId
	// Runnable returns the new KHITaskRunner instance.
	// The implementation of this function must create a new instance for each calls.
	Runnable(taskMode int) Runnable
}

// Runnable is an interface of the actual task implementation.
type Runnable interface {
	Run(ctx context.Context, v *VariableSet) error
}

type funcRunnableImpl struct {
	f func(ctx context.Context, v *VariableSet) error
}

// Run implements Runnable.
func (f *funcRunnableImpl) Run(ctx context.Context, v *VariableSet) error {
	return f.f(ctx, v)
}

var _ Runnable = (*funcRunnableImpl)(nil)

// NewRunnableFunc is an utility function to generate a new instance implements Runnable from a function.
func NewRunnableFunc(f func(ctx context.Context, v *VariableSet) error) Runnable {
	return &funcRunnableImpl{f: f}
}

type ConstantDefinitionImpl struct {
	id                taskid.TaskImplementationId
	labels            *LabelSet
	dependencies      []taskid.TaskReferenceId
	runnableGenerator func(taskMode int) Runnable
}

// Dependencies implements Definition.
func (c *ConstantDefinitionImpl) Dependencies() []taskid.TaskReferenceId {
	return c.dependencies
}

// ID implements Definition.
func (c *ConstantDefinitionImpl) ID() taskid.TaskImplementationId {
	return c.id
}

// Labels implements Definition.
func (c *ConstantDefinitionImpl) Labels() *LabelSet {
	return c.labels
}

// Runnable implements Definition.
func (c *ConstantDefinitionImpl) Runnable(taskMode int) Runnable {
	return c.runnableGenerator(taskMode)
}

var _ Definition = (*ConstantDefinitionImpl)(nil)

func NewDefinitionFromFunc(taskId taskid.TaskImplementationId, dependencies []taskid.TaskReferenceId, runnableGenerator func(taskMode int) Runnable, labelOpts ...LabelOpt) *ConstantDefinitionImpl {
	labels := NewLabelSet(labelOpts...)
	return &ConstantDefinitionImpl{
		id:                taskId,
		labels:            labels,
		dependencies:      taskid.DedupeReferenceIds(dependencies),
		runnableGenerator: runnableGenerator,
	}
}

type selectionPrioirtyLabelOpt struct {
	priority int
}

func (s *selectionPrioirtyLabelOpt) Write(ls *LabelSet) {
	ls.Set(LabelKeyTaskSelectionPriority, s.priority)
}

func WithSelectionPriority(priority int) LabelOpt {
	return &selectionPrioirtyLabelOpt{
		priority: priority,
	}
}
