// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package task

import (
	"context"

	"github.com/GoogleCloudPlatform/khi/pkg/common/typedmap"
	"github.com/GoogleCloudPlatform/khi/pkg/task/taskid"
)

const (
	KHISystemPrefix = "khi.google.com/"
)

// KHI allows tasks with different ID suffixes to be specified as dependencies
// using only the ID without the suffix. For example, both `a.b.c/qux#foo` and `a.b.c/qux#bar`
// can be specified as a dependency using `a.b.c/qux`.
//
// Normally, the task ID is uniquely determined by the task filter or other
// ways. However, if multiple tasks exist, the value specified with this label
// with the highest priority is used.
var LabelKeyTaskSelectionPriority = NewTaskLabelKey[int](KHISystemPrefix + "task-selection-priority")

// Definition represents a task definition that behaves as a factory of the task runner itself and contains metadata of dependency and labels.
// The implementation of ID and Labels must be deterministic when the application started.
// The implementation of Sinks and Source must be pure function not depending anything outside of the argument.
type Definition interface {
	// ID returns a string unique for each Definition
	// The implementation of this function must return a constant value.
	// Each definition ID must be unique but ID can have suffix beginning with #. Dependencies field will ignore the suffix.
	// This is useful when task A depends on the value B but value B can be generated from task B-1 or B-2 and the task set would be differently generated by some condition.
	// In the case, task Ids would be `B#1` and `B#2` and these could be depnd by specifying `B` in the Dependencies.
	ID() taskid.TaskImplementationId
	// Labels returns KHITaskLabelSet assigned to this task unit.
	// The implementation of this function must return a constant value.
	Labels() *typedmap.ReadonlyTypedMap

	// Dependencies returns the set of Definition ids without the suffix beginning with #. Task runner will wait these dependent tasks to be done before running this task.
	Dependencies() []taskid.TaskReferenceId

	Run(ctx context.Context, taskMode int, v *VariableSet) (any, error)
}

type ConstantDefinitionImpl struct {
	id           taskid.TaskImplementationId
	labels       *typedmap.ReadonlyTypedMap
	dependencies []taskid.TaskReferenceId
	runFunc      func(ctx context.Context, taskMode int, v *VariableSet) (any, error)
}

// Run implements Definition.
func (c *ConstantDefinitionImpl) Run(ctx context.Context, taskMode int, v *VariableSet) (any, error) {
	return c.runFunc(ctx, taskMode, v)
}

// Dependencies implements Definition.
func (c *ConstantDefinitionImpl) Dependencies() []taskid.TaskReferenceId {
	return c.dependencies
}

// ID implements Definition.
func (c *ConstantDefinitionImpl) ID() taskid.TaskImplementationId {
	return c.id
}

// Labels implements Definition.
func (c *ConstantDefinitionImpl) Labels() *typedmap.ReadonlyTypedMap {
	return c.labels
}

var _ Definition = (*ConstantDefinitionImpl)(nil)

func NewDefinitionFromFunc(taskId taskid.TaskImplementationId, dependencies []taskid.TaskReferenceId, runFunc func(ctx context.Context, taskMode int, v *VariableSet) (any, error), labelOpts ...LabelOpt) *ConstantDefinitionImpl {
	labels := NewLabelSet(labelOpts...)
	return &ConstantDefinitionImpl{
		id:           taskId,
		labels:       labels,
		dependencies: taskid.DedupeReferenceIds(dependencies),
		runFunc:      runFunc,
	}
}
